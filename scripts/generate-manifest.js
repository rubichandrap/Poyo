import fs from "node:fs";
import path from "node:path";
import { fileURLToPath } from "node:url";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// 1. Read Vite's manifest to know exactly which files are active
const viteManifestPath = path.join(
	__dirname,
	"..",
	"Poyo.client",
	"dist",
	".vite",
	"manifest.json",
);
if (!fs.existsSync(viteManifestPath)) {
	console.error("âŒ Vite manifest not found at:", viteManifestPath);
	process.exit(1);
}

const viteManifest = JSON.parse(fs.readFileSync(viteManifestPath, "utf8"));

// 2. Identify the entry point (usually index.html or the main TSX)
// We look for the entry chunk to get the main JS and CSS
const entryKey = Object.keys(viteManifest).find(
	(key) => viteManifest[key].isEntry,
);
if (!entryKey) {
	console.error("âŒ Could not find entry point in Vite manifest");
	process.exit(1);
}

const entryChunk = viteManifest[entryKey];
const mainJs = entryChunk.file;
const mainCss = entryChunk.css ? entryChunk.css[0] : null;

// 3. Collect ALL active files to copy
const activeFiles = new Set();
for (const key in viteManifest) {
	const chunk = viteManifest[key];
	activeFiles.add(chunk.file);
	if (chunk.css) {
		chunk.css.forEach((cssFile) => {
			activeFiles.add(cssFile);
		});
	}
	if (chunk.assets) {
		chunk.assets.forEach((assetFile) => {
			activeFiles.add(assetFile);
		});
	}
}

// 4. Prepare generated assets folder in wwwroot (Do NOT wipe entire folder to avoid EPERM on Windows)
const generatedAssetsPath = path.join(
	__dirname,
	"..",
	"Poyo.Server",
	"wwwroot",
	"generated",
);

if (!fs.existsSync(generatedAssetsPath)) {
	fs.mkdirSync(generatedAssetsPath, { recursive: true });
} else {
	console.log("ðŸ§¹ Selective cleanup of old assets in wwwroot/generated...");
	const existingFiles = fs.readdirSync(generatedAssetsPath);
	existingFiles.forEach((file) => {
		const relativePath = `generated/${file}`;
		if (!activeFiles.has(relativePath)) {
			try {
				fs.unlinkSync(path.join(generatedAssetsPath, file));
				console.log(`  ðŸ—‘ï¸ Deleted stale file: ${file}`);
			} catch (err) {
				console.warn(`  âš ï¸ Could not delete locked file ${file}:`, err.message);
			}
		}
	});
}

// 5. Copy ONLY active files from dist to wwwroot/generated
const distPath = path.join(__dirname, "..", "Poyo.client", "dist");
activeFiles.forEach((file) => {
	const srcPath = path.join(distPath, file);
	const destPath = path.join(
		__dirname,
		"..",
		"Poyo.Server",
		"wwwroot",
		file,
	);

	// Ensure parent directory exists (e.g. for generated/ folder)
	fs.mkdirSync(path.dirname(destPath), { recursive: true });

	if (fs.existsSync(srcPath)) {
		fs.copyFileSync(srcPath, destPath);
	}
});

console.log(`âœ… Synced ${activeFiles.size} active assets to wwwroot`);

// 6. Update server manifest with root-relative paths
const updatedManifest = {
	js: mainJs.startsWith("/") ? mainJs : "/" + mainJs,
	css: mainCss ? (mainCss.startsWith("/") ? mainCss : "/" + mainCss) : null,
};

// Write manifest to server wwwroot
const manifestPath = path.join(
	__dirname,
	"..",
	"Poyo.Server",
	"wwwroot",
	"manifest.json",
);
fs.writeFileSync(manifestPath, JSON.stringify(updatedManifest, null, 2));

// 7. Generate _ReactAssets.cshtml file
const scriptsPath = path.join(
	__dirname,
	"..",
	"Poyo.Server",
	"Views",
	"Shared",
	"_ReactAssets.cshtml",
);
const scriptsContent = `@*
    This file is automatically generated - DO NOT EDIT
    Generated by React build process
*@

<script type="module" crossorigin src="${updatedManifest.js}"></script>
${updatedManifest.css ? `<link rel="stylesheet" crossorigin href="${updatedManifest.css}">` : ""}`;

fs.writeFileSync(scriptsPath, scriptsContent);

console.log("Build manifest updated:", updatedManifest);
console.log("_ReactAssets.cshtml updated");

